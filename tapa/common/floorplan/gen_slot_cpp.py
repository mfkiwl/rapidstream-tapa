"""Generate floorplan slot cpp for hls synth."""

__copyright__ = """
Copyright (c) 2025 RapidStream Design Automation, Inc. and contributors.
All rights reserved. The contributor(s) of this file has/have agreed to the
RapidStream Contributor License Agreement.
"""

import re
from string import Template

_SCALAR_PRAGMA = (
    "#pragma HLS interface ap_none port = {name} register\n"
    "  {{ auto val = reinterpret_cast<volatile uint8_t &>({name}); }}"
)
_MMAP_PRAGMA = (
    "#pragma HLS interface ap_none port = {name}_offset register\n"
    "  {{ auto val = reinterpret_cast<volatile uint8_t &>({name}_offset); }}"
)
_FIFO_IN_PRAGMA = (
    "#pragma HLS disaggregate variable = {name}\n"
    "#pragma HLS interface ap_fifo port = {name}._\n"
    "#pragma HLS aggregate variable = {name}._ bit\n"
    "  void({name}._.empty());\n"
    "  {{ auto val = {name}.read(); }}\n"
)
_FIFO_OUT_PRAGMA = (
    "#pragma HLS disaggregate variable = {name}\n"
    "#pragma HLS interface ap_fifo port = {name}._\n"
    "#pragma HLS aggregate variable = {name}._ bit\n"
    "  void({name}._.full());\n"
    "  {name}.write({type}());"
)

_PRAGMA = {
    "scalar": _SCALAR_PRAGMA,
    "async_mmap": _MMAP_PRAGMA,
    "mmap": _MMAP_PRAGMA,
    "hmap": _SCALAR_PRAGMA,
    "istream": _FIFO_IN_PRAGMA,
    "ostream": _FIFO_OUT_PRAGMA,
    "istreams": _FIFO_IN_PRAGMA,
    "ostreams": _FIFO_OUT_PRAGMA,
}

_SCALAR_PORT_TEMPLATE = "{type} {name}"
_MMAP_PORT_TEMPLATE = "{type} {name}_offset"
_PORT_TEMPLATE = {
    "istream": "tapa::istream<{type}>& {name}",
    "ostream": "tapa::ostream<{type}>& {name}",
    "istreams": "tapa::istream<{type}>& {name}",
    "ostreams": "tapa::ostream<{type}>& {name}",
    "scalar": _SCALAR_PORT_TEMPLATE,
    "mmap": _MMAP_PORT_TEMPLATE,
    "hmap": _SCALAR_PORT_TEMPLATE,
    "async_mmap": _MMAP_PORT_TEMPLATE,
}
_DEF_TEMPLATE = """void $name($ports) {
    $pragma
}
"""

_DECL_TEMPLATE = """void $name($ports);
"""


def gen_slot_cpp(slot_name: str, top_name: str, ports: list, top_cpp: str) -> str:
    """Generate floorplan slot cpp for hls synth.

    slot_name: Name of the slot
    ports: List of ports in the slot. Each port should match port format
        in tapa graph dict.
        e.g.
        {
            "cat": "istream",
            "name": "a",
            "type": "float",
            "width": 32
        }
    """
    cpp_ports = []
    cpp_pragmas = []
    for port in ports:
        assert isinstance(port, dict)
        assert "cat" in port
        assert "name" in port
        assert "type" in port
        assert "width" in port
        assert port["cat"] in _PORT_TEMPLATE
        port_type = port["type"]
        port_cat = port["cat"]

        # if "name[idx]" exists, replace it with "name_idx"
        match = re.fullmatch(r"([a-zA-Z_]\w*)\[(\d+)\]", port["name"])
        if match:
            n, i = match.groups()
            name = f"{n}_{i}"
        elif "[" in port and "]" in port:
            msg = f"Invalid port index in '{port}': must be a numeric index."
            raise ValueError(msg)
        else:
            name = port["name"]

        # when port is an array, find array element type
        # TODO: fix scalar cat due to mmap/streams
        if port_cat == "scalar":
            match = re.search(r"(?:tapa::)?(\w+)<([^,>]+)", port_type)
            if match:
                port_cat = match.group(1)
                port_type = match.group(2)

        # convert pointer to uint64_t
        if "*" in port_type:
            port_type = "uint64_t"

        # remove const from type for reinterpret_cast
        port_type = port_type.removeprefix("const ")

        cpp_ports.append(
            _PORT_TEMPLATE[port_cat].format(
                name=name,
                type=port_type,
            )
        )
        assert port_cat in _PRAGMA, port_cat
        cpp_pragmas.append(_PRAGMA[port_cat].format(name=name, type=port_type))
        continue

    # Read template from file
    def_template = Template(_DEF_TEMPLATE)
    decl_template = Template(_DECL_TEMPLATE)

    # Substitute values
    new_def = def_template.substitute(
        name=slot_name,
        ports=", ".join(cpp_ports),
        pragma="\n".join(cpp_pragmas),
    )
    new_decl = decl_template.substitute(
        name=slot_name,
        ports=", ".join(cpp_ports),
    )

    return replace_function(
        top_cpp,
        top_name,
        new_decl,
        new_def,
    )


# Below are generated by AI


def remove_comments_and_strings(code: str) -> str:
    """Removes comments from C++ code, preserving strings and character literals.

    Args:
        code: The input C++ source code.

    Returns:
        A string with all comments replaced by spaces, leaving strings and chars intact.
    """

    def replacer(match: re.Match) -> str:
        s = match.group(0)
        if s.startswith("/"):
            return " " * len(s)  # preserve spacing for indexing
        return s  # keep string literals untouched

    pattern = r"""
        //.*?$|              # single-line comments
        /\*.*?\*/|           # multi-line comments
        "(?:\\.|[^"\\])*"|   # double-quoted strings
        '(?:\\.|[^'\\])*'    # single-quoted characters
    """
    return re.sub(pattern, replacer, code, flags=re.DOTALL | re.MULTILINE)


def find_extern_c_function_block(
    code: str, func_name: str, is_definition: bool
) -> tuple[int, int] | None:
    """Finds the start & end index of the extern "C" block of the given function.

    Args:
        code: The full source code.
        func_name: Name of the function to locate.
        is_definition: Whether to look for a definition (with body) or
            declaration (ending in semicolon).

    Returns:
        A tuple (start_index, end_index) of the full extern "C" block,
        or None if not found.
    """
    if is_definition:
        signature = rf"void\s+{re.escape(func_name)}\s*\([^)]*\)\s*\{{"
    else:
        signature = rf"void\s+{re.escape(func_name)}\s*\([^)]*\)\s*;"

    # Full extern "C" block pattern
    pattern = (
        rf'extern\s+"C"\s*\{{\s*'
        rf"{signature}.*?"
        rf'\}}\s*//\s*extern\s+"C"'
    )

    match = re.search(pattern, code, flags=re.DOTALL)
    if match:
        return match.start(), match.end()
    return None


def remove_extern_c_function_block(
    code: str, func_name: str, is_definition: bool
) -> str:
    """Removes the extern "C" block containing the specified function.

    Args:
        code: The source code.
        func_name: The name of the function.
        is_definition: Whether it's a definition or declaration.

    Returns:
        The source code with the block removed.
    """
    bounds = find_extern_c_function_block(code, func_name, is_definition)
    if bounds:
        start, end = bounds
        return code[:start] + code[end:]
    return code


def replace_function(code: str, func_name: str, new_decl: str, new_def: str) -> str:
    """Replaces both the extern "C" declaration and definition of a function.

    Args:
        code: The original source code.
        func_name: The function to replace.
        new_decl: The new declaration (e.g., `void foo(int x);`)
        new_def: The new full definition (e.g., `void foo(int x) { ... }`)

    Returns:
        The updated source code with the function declaration and definition replaced.
    """
    # Remove old extern "C" declaration and definition blocks
    code = remove_extern_c_function_block(code, func_name, is_definition=False)
    code = remove_extern_c_function_block(code, func_name, is_definition=True)

    # Append new extern "C" declaration and definition blocks to the end
    decl_block = f'extern "C" {{\n{new_decl.strip()}\n}}  // extern "C"\n'
    def_block = f'extern "C" {{\n{new_def.strip()}\n}}  // extern "C"\n'
    return code.rstrip() + "\n\n" + decl_block + "\n\n" + def_block + "\n"
