"""Pack the generated RTL into a Xilinx object file."""

__copyright__ = """
Copyright (c) 2024 RapidStream Design Automation, Inc. and contributors.
All rights reserved. The contributor(s) of this file has/have agreed to the
RapidStream Contributor License Agreement.
"""

import logging
import os
import tempfile
import zipfile
from pathlib import Path
from typing import Literal

import click
from yaml import safe_dump

from tapa.core import Program
from tapa.steps.common import is_pipelined, load_persistent_context, load_tapa_program

_logger = logging.getLogger().getChild(__name__)

VITIS_COMMAND_BASIC = [
    "v++ ${DEBUG} \\",
    "  --link \\",
    '  --output "${OUTPUT_DIR}/${TOP}_${PLATFORM}.xclbin" \\',
    "  --kernel ${TOP} \\",
    "  --platform ${PLATFORM} \\",
    "  --target ${TARGET} \\",
    "  --report_level 2 \\",
    '  --temp_dir "${OUTPUT_DIR}/${TOP}_${PLATFORM}.temp" \\',
    "  --optimize 3 \\",
    "  --connectivity.nk ${TOP}:1:${TOP} \\",
    "  --save-temps \\",
    '  "${XO}" \\',
    "  --vivado.synth.jobs ${MAX_SYNTH_JOBS} \\",
    "  --vivado.prop=run.impl_1.STEPS.PHYS_OPT_DESIGN.IS_ENABLED=1 \\",
    "  --vivado.prop=run.impl_1.STEPS.OPT_DESIGN.ARGS.DIRECTIVE=$STRATEGY \\",
    "  --vivado.prop=run.impl_1.STEPS.PLACE_DESIGN.ARGS.DIRECTIVE=$PLACEMENT_STRATEGY \\",  # noqa: E501
    "  --vivado.prop=run.impl_1.STEPS.PHYS_OPT_DESIGN.ARGS.DIRECTIVE=$STRATEGY \\",
    "  --vivado.prop=run.impl_1.STEPS.ROUTE_DESIGN.ARGS.DIRECTIVE=$STRATEGY \\",
]
CONFIG_OPTION = ['  --config "${CONFIG_FILE}" \\']
CLOCK_OPTION = ["  --kernel_frequency ${TARGET_FREQUENCY} \\"]
NEWLINE = [""]


@click.command()
@click.option(
    "--output",
    "-o",
    type=click.Path(dir_okay=False, writable=True),
    required=False,
    help="Output packed .xo Xilinx object file.",
)
@click.option(
    "--bitstream-script",
    "-s",
    type=click.Path(dir_okay=False, writable=True),
    help="Script file to generate the bitstream.",
)
@click.option(
    "--custom-rtl",
    multiple=True,
    type=Path,
    default=(),
    help="Add rtl files or folders to the project. "
    "The rtl will replace the default rtl "
    "generated by TAPA. Currently only support .v format. "
    'Use [[tapa::target("non_synthesizable", "xilinx")]] to generate the'
    "template for the custom rtl",
)
def pack(
    output: str | None,
    bitstream_script: str | None,
    custom_rtl: tuple[Path, ...],
) -> None:
    """Pack the generated RTL into a Xilinx object file."""
    program = load_tapa_program()
    settings = load_persistent_context("settings")
    vitis_mode = settings.get("vitis-mode", True)
    flow_type = settings.get("flow_type", "hls")

    if flow_type == "aie":
        return

    if custom_rtl:
        templates_info = load_persistent_context("templates_info")
        program.replace_custom_rtl(custom_rtl, templates_info)

    if vitis_mode:
        output = _enforce_path_suffix(
            output, suffix=".xo", reason="you are in Vitis mode"
        )
        program.pack_xo(output)
        if bitstream_script is not None:
            with open(bitstream_script, "w", encoding="utf-8") as script:
                script.write(
                    get_vitis_script(
                        program.top,
                        output,
                        settings.get("platform", None),
                        settings.get("clock-period", None),
                        settings.get("connectivity", None),
                    )
                )
                _logger.info("generate the v++ script at %s", bitstream_script)
    else:
        output = _enforce_path_suffix(
            output, suffix=".zip", reason="you are not in Vitis mode"
        )
        pack_zip(program, output)
        if bitstream_script is not None:
            _logger.warning(
                "you are not in Vitis mode, the bitstream script will not be generated."
            )

    is_pipelined("pack", True)


def _enforce_path_suffix(
    path: str | None,
    suffix: Literal[".xo", ".zip"],
    reason: str,
) -> str:
    if path is None:
        path = f"work{suffix}"
    if not path.endswith(suffix):
        path = f"{path}{suffix}"
        _logger.warning(
            "%s, the generated RTL will be packed into a %s file: %s.",
            reason,
            suffix,
            path,
        )
    return path


def get_vitis_script(
    top: str,
    output_file: str,
    platform: str | None,
    clock_period: str | None,
    connectivity: str | None,
) -> str:
    """Generate v++ commands to run implementation."""
    script = []
    script.append("#!/bin/bash")

    vitis_command = VITIS_COMMAND_BASIC

    script.extend(("TARGET=hw", "# TARGET=hw_emu", "# DEBUG=-g"))
    script += NEWLINE

    script.append(f"TOP={top}")
    script.append(f"XO='{os.path.abspath(output_file)}'")

    if connectivity:
        orig_config_path = os.path.abspath(connectivity)
        _logger.info(
            "use the original connectivity configuration at %s in the v++ script",
            orig_config_path,
        )
        script.append(f"CONFIG_FILE='{orig_config_path}'")
        vitis_command += CONFIG_OPTION
    else:
        _logger.warning(
            "No connectivity file is provided, skip this part in the v++ script.",
        )

    # if not specified in tapac, use platform default
    if clock_period:
        freq_mhz = round(1000 / float(clock_period))
        script.append(f"TARGET_FREQUENCY={freq_mhz}")
        vitis_command += CLOCK_OPTION
    else:
        script.append('>&2 echo "Using the default clock target of the platform."')

    # if platform not specified in tapac, need to manually add it
    if platform:
        script.append(f"PLATFORM={platform}")
    else:
        script.append('PLATFORM=""')
        warning_msg = (
            'Please edit this file and set a valid PLATFORM= on line "${LINENO}"'
        )
        script.append(f"if [ -z $PLATFORM ]; then echo {warning_msg}; exit; fi")
        script += NEWLINE

    script.append(r'OUTPUT_DIR="$(pwd)/vitis_run_${TARGET}"')
    script += NEWLINE

    script.append(r"MAX_SYNTH_JOBS=8")
    script.append(r'STRATEGY="Explore"')
    script.append(r'PLACEMENT_STRATEGY="EarlyBlockPlacement"')
    script += NEWLINE

    script += vitis_command
    script += NEWLINE

    return "\n".join(script)


def pack_zip(program: Program, output: str) -> None:
    """Pack the generated RTL into a zip file.

    Args:
        program: The program object.
        output: The output zip file.
    """
    _logger.info("packing the design into a zip file: %s", output)

    with (
        tempfile.TemporaryFile() as tmp_file,
        zipfile.ZipFile(tmp_file, "w") as tmp_zipf,
    ):
        _logger.info("adding the RTL to the zip file")
        all_files = Path(program.rtl_dir).glob("**")
        for file in all_files:
            if file.is_file():
                tmp_zipf.write(file, f"rtl/{file.relative_to(program.rtl_dir)}")
                _logger.debug("added %s to the zip file", file)

        _logger.info("adding the TAPA information to the zip file")
        for filename in program.report_paths:
            file = Path(filename)
            # filter out unreadable json files
            if file.suffix == ".json":
                continue
            tmp_zipf.write(file, f"{file.name}")
            _logger.debug("added %s to the zip file", file)

        graph = load_persistent_context("graph")
        tmp_zipf.writestr("graph.yaml", safe_dump(graph))
        _logger.debug("added graph.yaml to the zip file")

        settings = load_persistent_context("settings")
        tmp_zipf.writestr("settings.yaml", safe_dump(settings))
        _logger.debug("added settings.yaml to the zip file")

        _logger.info("adding the HLS reports to the zip file")
        report_files = Path(program.report_dir).glob("**/*_csynth.rpt")
        for file in report_files:
            tmp_zipf.write(file, f"report/{file.relative_to(program.report_dir)}")
            _logger.debug("added %s to the zip file", file)

        # redact timestamp, source location etc. to make zip reproducible
        _logger.info("generating the final zip file")
        with zipfile.ZipFile(output, "w") as output_zipf:
            for info in tmp_zipf.infolist():
                redacted_info = zipfile.ZipInfo(info.filename)
                redacted_info.compress_type = zipfile.ZIP_DEFLATED
                redacted_info.external_attr = info.external_attr
                output_zipf.writestr(redacted_info, tmp_zipf.read(info))

    _logger.info("packed the design into a zip file: %s", output)
