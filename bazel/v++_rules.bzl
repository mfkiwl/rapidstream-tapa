"""Custom rule to add V++ target to the target list."""

# Copyright (c) 2024 RapidStream Design Automation, Inc. and contributors.
# All rights reserved. The contributor(s) of this file has/have agreed to the
# RapidStream Contributor License Agreement.

load("@bazel_skylib//rules:common_settings.bzl", "BuildSettingInfo")

# Define the implementation of vpp target.
def _vpp_xclbin_impl(ctx):
    # Retrieve the inputs and attributes from the rule invocation.
    vpp = ctx.executable.vpp
    xo = ctx.file.xo
    target = ctx.attr.target
    top_name = ctx.attr.top_name
    platform_name = ctx.attr.platform_name
    xclbin = ctx.actions.declare_file(
        ctx.attr.xclbin or "{}.{}.{}.xclbin".format(
            top_name,
            platform_name,
            target,
        ),
    )

    # Start building the command to run v++.
    vpp_cmd = [
        "--link",
        "--output",
        xclbin.path,
        "--kernel",
        top_name,
        "--platform",
        platform_name,
        "--target",
        target,
        "--connectivity.nk",
        "{top_name}:1:{top_name}".format(top_name = top_name),
        xo.path,
    ]

    if target == "hw_emu":
        # Reduce `mt_level` to avoid excessive amount of processes. Run time of
        # `bazel build //tests/apps/vadd:vadd-hw-emu-xclbin` for reference:
        #   mt_level=1: 651s ("off", +67%)
        #   mt_level=2: 483s (+24$)
        #   mt_level=4: 405s (+4%)
        #   mt_level=8: 390s (default)
        vpp_cmd += [
            "--vivado.prop=fileset.sim_1.xsim.compile.xsc.mt_level=2",
            "--vivado.prop=fileset.sim_1.xsim.elaborate.mt_level=2",
        ]

    # Define a custom action to run the synthesized command.
    ctx.actions.run(
        outputs = [xclbin],
        inputs = [xo],
        tools = [vpp],
        executable = vpp,
        arguments = vpp_cmd,
        mnemonic = "VppLink",
        resource_set = _resource_set,
    )

    # Return default information, including the output file.
    return [DefaultInfo(files = depset([xclbin]))]

# Tell bazel v++ consumes a lot of memory. 2GB is a conservative estimation that
# avoids wasting memory.
def _resource_set(_os, _num_inputs):
    return {"memory": 2000}  # MB

# Define the v++ rule.
vpp_xclbin = rule(
    implementation = _vpp_xclbin_impl,
    attrs = {
        "vpp": attr.label(
            cfg = "exec",
            default = Label("//bazel:v++"),
            executable = True,
            doc = "The v++ executable.",
        ),
        "xo": attr.label(
            allow_single_file = True,
            mandatory = True,
            doc = "The source xo file to be linked.",
        ),
        "top_name": attr.string(
            mandatory = True,
            doc = "The top function name of the kernel.",
        ),
        "platform_name": attr.string(
            mandatory = True,
            doc = "The platform name for the kernel.",
        ),
        "target": attr.string(
            mandatory = True,
            doc = "The target to be linked (sw_emu, hw_emu, hw).",
            values = ["sw_emu", "hw_emu", "hw"],
        ),
        "xclbin": attr.string(
            mandatory = False,
            doc = "The output xclbin file name for the kernel.",
        ),
    },
)

def _xilinx_wrapper_impl(ctx):
    output = ctx.actions.declare_file(ctx.attr.name)
    tool_path = "{}/{}/{}".format(
        ctx.attr._tool_path[BuildSettingInfo].value,
        ctx.attr.tool,
        ctx.attr.tool_version or ctx.attr._tool_version[BuildSettingInfo].value,
    )
    lines = [
        "#!/bin/bash",
        "set -e",
        "source {}/settings64.sh".format(tool_path),
    ]
    if ctx.attr.xrt:
        lines.append("source /opt/xilinx/xrt/setup.sh")
    lines.append("export HOME=/tmp")  # Dump trash generated by Vivado to /tmp
    if ctx.attr.argv0:
        lines.append('exec {} "$@"'.format(ctx.attr.argv0))
    else:
        lines.append('exec "$@"')
    ctx.actions.write(output, "\n".join(lines), is_executable = True)
    return [DefaultInfo(executable = output)]

# Generates a shell script wrapper that sets up necessary Xilinx environment.
xilinx_wrapper = rule(
    implementation = _xilinx_wrapper_impl,
    executable = True,
    attrs = {
        "tool": attr.string(
            mandatory = True,
            doc = "The Xilinx tool under the tool path, e.g., Vivado, Vitis.",
        ),
        "argv0": attr.string(
            doc = 'Optional "$0" prepended to "$@".',
        ),
        "xrt": attr.bool(
            default = False,
            doc = "If true, also set up XRT environment.",
        ),
        "tool_version": attr.string(
            doc = "Overrides the tool version just for this target.",
        ),
        "_tool_path": attr.label(
            default = "//bazel:xilinx_tool_path",
        ),
        "_tool_version": attr.label(
            default = "//bazel:xilinx_tool_version",
        ),
    },
)
